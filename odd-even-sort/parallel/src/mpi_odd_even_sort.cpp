//
// Created by cjdcoy on 19/09/19.
//

#include "mpi_odd_even_sort.h"
#include <cmath>

const int g_root = 0;

/**
 *
 * @param content content to print
 * @param size size of the array
 * @param n print until n
 *
 *
 */
static void print_data(int *content, int size, int n)
{
    for (int i = 0 ; i < size && i < n ; i++)
        std::cout << content[i] << " ";
    std::cout<<std::endl;
}

void parallel_mandlebrot(XlibWrap &xlib, std::vector<int> &lines, std::pair<int, int> &x_conditions)
{
    Compl   z, c;
    int k = 0;
    float ratio1 = WIN_SIZE / (float)2;
    float ratio2 = WIN_SIZE / (float)4;

    for (auto y : lines) {
        for (int x = x_conditions.first ; x < WIN_SIZE ; x+= x_conditions.second) {
            z.real = z.imag = 0.0;
            c.real = ((float) x - ratio1)/(ratio2);               // scale factors for 800 x 800 window
            c.imag = ((float) y - ratio1)/(ratio2);
            k = 0;
            double  lengthsq = 0, temp = 0;
            while (lengthsq < 20 && k < g_max_iter)    {                                     //     iterate for pixel color

                temp = z.real*z.real - z.imag*z.imag + c.real;
                z.imag = 2.0*z.real*z.imag + c.imag;
                z.real = temp;
                lengthsq = z.real*z.real+z.imag*z.imag;
                if (k < g_max_iter && k > 0)
                    xlib.put_pixel(x, y, z.real,0, z.real);
                k++;
            }
        }
    }
}

/**
 *
 * @param container contains information about the data that has been scattered
 *
 * the master programs receives the gathered data from all the different processes
 */
static void gather_data(data_t *container)
{
    int global_array_size = 0;
    int *global_array = NULL;

    if (container->mpi_id == g_root) {
        for (int i=0; i< container->mpi_tot_id; i++)
            global_array_size += container->elem_per_proc[i];   /* plus one for space or \0 after words */

        global_array = (int*)malloc(global_array_size * sizeof(int));
        for (int i=0; i<global_array_size-1; i++)
            global_array[i] = ' ';
        global_array[global_array_size-1] = '\0';
    }

    MPI_Gatherv(container->array, container->size_array, MPI_INT, global_array, container->elem_per_proc, container->offset, MPI_INT, g_root, MPI_COMM_WORLD);
    container->global_array = global_array;
    container->global_array_size = global_array_size;
}

void reset_data_t(data_t *container)
{
    if (container->array != NULL)
        free(container->array);
    container->size_array = 0;
    container->mpi_id = 0;

    //global information about the array distribution
    if (container->elem_per_proc != NULL)
        free(container->elem_per_proc);
    if (container->offset != NULL)
        free(container->offset);

    //global informations
    if (container->global_array != NULL)
        free(container->global_array);
    container->global_array_size = 0;
    container->mpi_tot_id = 0;
}

/**
 *
 * @param random_vect vector containing all the random numbers unsorted
 * @param vect_size size of the vector
 * @param mpi_tot_id total number of nodes
 *
 * this is basically the master main function which whill scatter, process and gather the vector of random numbers
 */
void mpi_master()
{
    int mpi_id; MPI_Comm_rank(MPI_COMM_WORLD, &mpi_id);
    data_t container;

    std::cout << "random array: ";
    print_data(random_vect, vect_size, 20);
    odd_even_sort(container);
    gather_data(&container);

    std::cout << "sorted array: ";
    print_data(container.global_array, container.global_array_size, 20);
    //reset_data_t(&container);
}

/**
 *
 * @param vect_size size of the random vector that has been generated by the master
 * @param mpi_tot_id total number of nodes
 *
 *  his is basically the master main function which whill receive, process and send its portion of the vector of random numbers
 */
void mpi_slave()
{
    int mpi_id; MPI_Comm_rank(MPI_COMM_WORLD, &mpi_id);
    data_t container;

    odd_even_sort(container);
    gather_data(&container);
}